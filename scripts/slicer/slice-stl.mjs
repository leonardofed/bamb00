// Slices any head STL into x-y-z parts that reassemble in bamb00.
// ABSOLUTE paths required in CLI.
// Deps: npm i three three-csg-ts fs-extra yargs

import * as THREE from 'three'
import { STLLoader }   from 'three/examples/jsm/loaders/STLLoader.js'
import { STLExporter } from 'three/examples/jsm/exporters/STLExporter.js'
import { CSG } from 'three-csg-ts'
import fs from 'fs-extra'
import path from 'path'
import yargs from 'yargs/yargs'
import { hideBin } from 'yargs/helpers'

const argv = yargs(hideBin(process.argv))
  .option('in',      { type: 'string', demandOption: true,  desc: 'ABS path to input head.stl' })
  .option('out',     { type: 'string', demandOption: true,  desc: 'ABS path to assets/stl' })
  .option('config',  { type: 'string', demandOption: true,  desc: 'ABS path to scripts/grid-config.js' })
  .option('countX',  { type: 'number', default: 9 })
  .option('countY',  { type: 'number', default: 3 })
  .option('countZ',  { type: 'number', default: 9 })
  .option('rotXdeg', { type: 'number', default: 0 })
  .option('rotYdeg', { type: 'number', default: 0 })
  .option('rotZdeg', { type: 'number', default: 0 })
  .option('clean',   { type: 'boolean', default: false })
  .strict().help().argv

const mustAbs = (p,n)=>{ if(!path.isAbsolute(p)) throw new Error(`${n} must be absolute`); return p }
const inFile  = mustAbs(argv.in,'--in')
const outBase = mustAbs(argv.out,'--out')
const cfgPath = mustAbs(argv.config,'--config')

const {countX,countY,countZ} = argv
const cropX = countX, cropY = countY, cropZ = countZ
const setFolder = `${countX}-${countY}-${countZ}-${cropX}-${cropY}-${cropZ}`
const outDir = path.join(outBase, setFolder)

if (argv.clean && await fs.pathExists(outDir)) await fs.remove(outDir)
await fs.ensureDir(outDir); await fs.ensureDir(path.dirname(cfgPath))

// 1) Load head
const loader = new STLLoader()
const buf = await fs.readFile(inFile)
const geom = loader.parse(buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength))

// Optional pre-rotation (to make the bust face forward if your STL axes differ)
const eul = new THREE.Euler(
  THREE.MathUtils.degToRad(argv.rotXdeg),
  THREE.MathUtils.degToRad(argv.rotYdeg),
  THREE.MathUtils.degToRad(argv.rotZdeg),
  'XYZ'
)
geom.applyMatrix4(new THREE.Matrix4().makeRotationFromEuler(eul))

geom.computeVertexNormals()
geom.computeBoundingBox()
if (!geom.boundingBox) throw new Error('Could not compute bounding box')

const bbox   = geom.boundingBox.clone()
const size   = bbox.getSize(new THREE.Vector3())
const center = bbox.getCenter(new THREE.Vector3())

// 2) Normalize per-axis into unit cube [-0.5,+0.5]^3
//    (center at origin, then scale so each axis length is 1)
const T = new THREE.Matrix4().makeTranslation(-center.x, -center.y, -center.z)
const S = new THREE.Matrix4().makeScale(1/size.x, 1/size.y, 1/size.z)
const toUnit = new THREE.Matrix4().multiplyMatrices(S, T)

// Build normalized head mesh
const headNormGeom = geom.clone()
headNormGeom.applyMatrix4(toUnit)
const headMesh = new THREE.Mesh(headNormGeom, new THREE.MeshBasicMaterial())
headMesh.updateMatrixWorld(true)

// 3) Slice in normalized space using unit grid cells
const cellW = 1 / countX, cellH = 1 / countY, cellD = 1 / countZ
const exporter = new STLExporter()
const partsVis = Array.from({length:countX},()=>Array.from({length:countY},()=>Array(countZ).fill(false)))

let written = 0
console.time('slicing')

for (let x=0; x<countX; x++){
  for (let y=0; y<countY; y++){
    for (let z=0; z<countZ; z++){
      // cell center in unit space
      const cx = (x + 0.5) * cellW - 0.5
      const cy = (y + 0.5) * cellH - 0.5
      const cz = (z + 0.5) * cellD - 0.5

      const box = new THREE.BoxGeometry(cellW, cellH, cellD)
      box.translate(cx, cy, cz)

      const piece = CSG.intersect(headMesh, new THREE.Mesh(box))
      const pos = piece.geometry?.attributes?.position
      if (!pos || pos.count === 0) { box.dispose(); continue }

      // 4) Convert to cell-local: move cell center to origin.
      piece.geometry.translate(-cx, -cy, -cz)
      piece.geometry.computeVertexNormals()

      await fs.writeFile(path.join(outDir, `${x}-${y}-${z}.stl`), exporter.parse(piece))
      partsVis[x][y][z] = true
      written++

      piece.geometry.dispose(); box.dispose()
    }
  }
  process.stdout.write(`x=${x+1}/${countX} parts=${written}\r`)
}
console.log(`\nWrote ${written} parts → ${outDir}`)
console.timeEnd('slicing')

// 5) grid-config.js for the site
const cfg = `// Auto-generated by slice-stl.mjs
var countX=${countX}, countY=${countY}, countZ=${countZ};
var cropX=${cropX},  cropY=${cropY},  cropZ=${cropZ};
var partSizeX=${cellW}, partSizeY=${cellH}, partSizeZ=${cellD};
var partsVis=${JSON.stringify(partsVis)};`

await fs.writeFile(cfgPath, cfg, 'utf8')
console.log('Wrote config →', cfgPath)
